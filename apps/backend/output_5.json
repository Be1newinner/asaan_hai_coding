[
  {
    "lesson_id": 5,
    "content": "# Variables & Hoisting\n\n## Introduction\n\nVariables are fundamental to any programming language. They act as named storage locations for data. In JavaScript, variables allow you to store and manipulate information within your programs.  Understanding how variables work, and a concept called 'hoisting', is crucial for writing predictable and bug-free code.\n\n## Declaring Variables\n\nJavaScript offers three ways to declare variables:\n\n*   **`var`**:  The traditional way to declare variables.  It has function scope or global scope.  Avoid using `var` in modern JavaScript due to its potential for unexpected behavior.\n*   **`let`**: Introduced with ES6 (ECMAScript 2015).  `let` has block scope, meaning it's only accessible within the block of code where it's defined (e.g., inside an `if` statement or a `for` loop).\n*   **`const`**: Also introduced with ES6.  `const` is used to declare constants â€“ variables whose values cannot be reassigned after initialization.  Like `let`, it has block scope.\n\n**Example:**\n\n```javascript\nvar x = 10;\nlet y = 20;\nconst z = 30;\n\ny = 25; // Valid - let allows reassignment\n// z = 35; // Error - const does not allow reassignment\n```\n\n## Variable Scope\n\nScope determines the accessibility of variables.  \n\n*   **Global Scope:** Variables declared outside any function have global scope and can be accessed from anywhere in your code.\n*   **Function Scope:** Variables declared with `var` inside a function have function scope and are only accessible within that function.\n*   **Block Scope:** Variables declared with `let` and `const` inside a block (e.g., `if`, `for`, `while`) have block scope and are only accessible within that block.\n\n**Example:**\n\n```javascript\nfunction exampleScope() {\n  var functionScoped = \"I'm function scoped\";\n  let blockScoped = \"I'm block scoped\";\n  const constantValue = 100;\n\n  if (true) {\n    let innerBlockScoped = \"I'm inner block scoped\";\n    console.log(functionScoped); // Accessible\n    console.log(blockScoped); // Accessible\n    console.log(innerBlockScoped); // Accessible\n  }\n\n  // console.log(innerBlockScoped); // Error: innerBlockScoped is not defined\n}\n\nexampleScope();\n```\n\n## Hoisting\n\nHoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their scope before code execution.  However, *only the declarations are hoisted, not the initializations*.\n\n*   **`var` Hoisting:** Variables declared with `var` are hoisted and initialized with `undefined`. This means you can use a `var` variable before its declaration in the code, but its value will be `undefined`.\n*   **`let` and `const` Hoisting:** Variables declared with `let` and `const` are also hoisted, but they are *not* initialized.  Accessing them before their declaration results in a `ReferenceError` (this is often referred to as the \"Temporal Dead Zone\").\n\n**Example:**\n\n```javascript\nconsole.log(myVar); // Output: undefined (var is hoisted and initialized with undefined)\n// console.log(myLet); // Error: Cannot access 'myLet' before initialization\n// console.log(myConst); // Error: Cannot access 'myConst' before initialization\n\nvar myVar = 10;\nlet myLet = 20;\nconst myConst = 30;\n\nconsole.log(myVar); // Output: 10\nconsole.log(myLet); // Output: 20\nconsole.log(myConst); // Output: 30\n```\n\n## Best Practices\n\n*   **Use `let` and `const`:**  Prefer `let` and `const` over `var` to avoid the pitfalls of function scope and potential hoisting issues.\n*   **Declare Variables at the Top:**  Even with `let` and `const`, it's good practice to declare your variables at the top of their scope (e.g., at the beginning of a function or block) to improve readability and prevent unexpected behavior.\n*   **Use `const` for Constants:**  Use `const` whenever you have a variable whose value should not change.\n\n## Relevance to Modern Frameworks\n\n*   **React/Next.js:**  Understanding variable scope and hoisting is crucial when working with component state and event handlers.  Incorrect scoping can lead to unexpected re-renders or bugs.\n*   **Node.js/NestJS:**  In server-side JavaScript, proper variable management is essential for maintaining application state and handling requests efficiently.\n*   **Python (Comparison):** Python doesn't have hoisting in the same way JavaScript does. Variable scope is determined by where the variable is assigned, and attempting to use a variable before assignment will raise a `NameError`.  This makes Python's variable behavior more predictable.\n\nBy mastering variables and hoisting, you'll build a solid foundation for writing robust and maintainable JavaScript code."
  }
]